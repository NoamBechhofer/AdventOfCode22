'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function createPriorityQueue(cmp) {
    const _tree = [null];
    let _size = 0;
    return {
        init,
        enqueue,
        enqueues,
        dequeue,
        splice,
        replaceTop,
        top,
        collect,
        size: () => _size,
        isEmpty: () => _size < 1,
    };
    function _fastBuild() {
        for (let q = _size; q > 1; q -= 2)
            _down(q >> 1);
    }
    function init(elements, startIndex, endIndex) {
        if (!elements) {
            _size = 0;
            _tree.length = _size + 1;
            return;
        }
        const sIdx = Math.max(0, Math.min(elements.length, startIndex ?? 0));
        const tIdx = Math.max(sIdx, Math.min(elements.length, endIndex ?? elements.length));
        _size = tIdx - sIdx;
        if (_tree.length <= _size)
            _tree.length = _size + 1;
        for (let i = sIdx, k = 1; i < tIdx; ++i, ++k)
            _tree[k] = elements[i];
        _fastBuild();
    }
    function enqueue(element) {
        _tree[++_size] = element;
        _up(_size);
    }
    function enqueues(elements, startIndex, endIndex) {
        const sIdx = Math.max(0, Math.min(elements.length, startIndex ?? 0));
        const tIdx = Math.max(sIdx, Math.min(elements.length, endIndex ?? elements.length));
        const N = tIdx - sIdx;
        if (N < 5) {
            for (let i = sIdx; i < tIdx; ++i)
                enqueue(elements[i]);
            return;
        }
        let k = _size + 1;
        _size += N;
        if (_tree.length <= _size)
            _tree.length = _size + 1;
        for (let i = sIdx; i < tIdx; ++i, ++k)
            _tree[k] = elements[i];
        _fastBuild();
    }
    function dequeue() {
        if (_size < 1)
            return undefined;
        const target = _tree[1];
        _tree[1] = _tree[_size--];
        _down(1);
        return target;
    }
    function splice(filter, newElements, startIndex, endIndex) {
        let i = 0;
        for (let j = 1; j <= _size; ++j) {
            const element = _tree[j];
            if (filter(element))
                _tree[++i] = element;
        }
        if (newElements) {
            const L = newElements.length;
            const sIdx = Math.max(0, Math.min(L, startIndex ?? 0));
            const tIdx = Math.max(sIdx, Math.min(L, endIndex ?? L));
            for (let j = sIdx; j < tIdx; ++j)
                _tree[++i] = newElements[j];
        }
        _size = i;
        _fastBuild();
    }
    function replaceTop(newElement) {
        if (_size < 1)
            _tree[++_size] = newElement;
        else {
            _tree[1] = newElement;
            _down(1);
        }
    }
    function top() {
        return _size > 0 ? _tree[1] : undefined;
    }
    function collect() {
        return _tree.slice(1, _size + 1);
    }
    function _down(index) {
        for (let p = index; p <= _size;) {
            const lft = p << 1;
            const rht = lft | 1;
            if (lft > _size)
                break;
            const q = rht <= _size && cmp(_tree[rht], _tree[lft]) > 0 ? rht : lft;
            const tmp = _tree[q];
            if (cmp(_tree[p], tmp) >= 0)
                break;
            _tree[q] = _tree[p];
            _tree[p] = tmp;
            p = q;
        }
    }
    function _up(index) {
        for (let i = index; i > 1;) {
            const q = i >> 1;
            const x = _tree[q];
            if (cmp(x, _tree[i]) >= 0)
                break;
            _tree[q] = _tree[i];
            _tree[i] = x;
            i = q;
        }
    }
}

exports.createPriorityQueue = createPriorityQueue;
